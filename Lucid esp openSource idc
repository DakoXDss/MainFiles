--[[
    Enhanced ESP System
    Features: Box, Skeleton, Tracers, Health, Distance, Names, Chams, LookAt Indicators
    Optimized and cleaner architecture
]]

-- Services
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")

-- Variables
local LocalPlayer = Players.LocalPlayer
local Camera = Workspace.CurrentCamera
local Container = Instance.new("Folder", gethui and gethui() or game:GetService("CoreGui"))
Container.Name = "ESP_Container"

-- Math shortcuts
local floor = math.floor
local round = math.round
local sin = math.sin
local cos = math.cos
local sqrt = math.sqrt
local atan2 = math.atan2

-- Table shortcuts
local clear = table.clear
local insert = table.insert

-- Constants
local BONE_CONNECTIONS = {
    {"Head", "UpperTorso"},
    {"UpperTorso", "LowerTorso"},
    {"UpperTorso", "LeftUpperArm"},
    {"LeftUpperArm", "LeftLowerArm"},
    {"LeftLowerArm", "LeftHand"},
    {"UpperTorso", "RightUpperArm"},
    {"RightUpperArm", "RightLowerArm"},
    {"RightLowerArm", "RightHand"},
    {"LowerTorso", "LeftUpperLeg"},
    {"LeftUpperLeg", "LeftLowerLeg"},
    {"LeftLowerLeg", "LeftFoot"},
    {"LowerTorso", "RightUpperLeg"},
    {"RightUpperLeg", "RightLowerLeg"},
    {"RightLowerLeg", "RightFoot"}
}

local BONE_CONNECTIONS_R6 = {
    {"Head", "Torso"},
    {"Torso", "Left Arm"},
    {"Torso", "Right Arm"},
    {"Torso", "Left Leg"},
    {"Torso", "Right Leg"}
}

local BOX_VERTICES = {
    Vector3.new(-1, -1, -1), Vector3.new(-1, 1, -1),
    Vector3.new(-1, 1, 1), Vector3.new(-1, -1, 1),
    Vector3.new(1, -1, -1), Vector3.new(1, 1, -1),
    Vector3.new(1, 1, 1), Vector3.new(1, -1, 1)
}

-- Utility Functions
local function WorldToScreen(position)
    local screen, onScreen = Camera:WorldToViewportPoint(position)
    return Vector2.new(screen.X, screen.Y), onScreen, screen.Z
end

local function GetCharacterBounds(character)
    local parts = {}
    for _, child in ipairs(character:GetChildren()) do
        if child:IsA("BasePart") and (child.Name:find("Torso") or child.Name:find("Head") or 
           child.Name:find("Arm") or child.Name:find("Leg") or child.Name:find("Foot") or child.Name:find("Hand")) then
            insert(parts, child)
        end
    end
    
    if #parts == 0 then return nil, nil end
    
    local min, max = parts[1].Position, parts[1].Position
    for _, part in ipairs(parts) do
        local pos, size = part.Position, part.Size
        min = Vector3.new(
            math.min(min.X, pos.X - size.X/2),
            math.min(min.Y, pos.Y - size.Y/2),
            math.min(min.Z, pos.Z - size.Z/2)
        )
        max = Vector3.new(
            math.max(max.X, pos.X + size.X/2),
            math.max(max.Y, pos.Y + size.Y/2),
            math.max(max.Z, pos.Z + size.Z/2)
        )
    end
    
    local center = (min + max) * 0.5
    return CFrame.new(center, center + Vector3.new(0, 0, 1)), max - min
end

local function CalculateBoxCorners(cframe, size)
    local corners = {}
    for i, vertex in ipairs(BOX_VERTICES) do
        local worldPos = (cframe * CFrame.new(size * 0.5 * vertex)).Position
        corners[i], _, _ = WorldToScreen(worldPos)
    end
    
    local minX, minY = math.huge, math.huge
    local maxX, maxY = -math.huge, -math.huge
    
    for _, corner in ipairs(corners) do
        minX = math.min(minX, corner.X)
        minY = math.min(minY, corner.Y)
        maxX = math.max(maxX, corner.X)
        maxY = math.max(maxY, corner.Y)
    end
    
    return {
        topLeft = Vector2.new(floor(minX), floor(minY)),
        topRight = Vector2.new(floor(maxX), floor(minY)),
        bottomLeft = Vector2.new(floor(minX), floor(maxY)),
        bottomRight = Vector2.new(floor(maxX), floor(maxY)),
        corners = corners
    }
end

local function IsR15(character)
    return character:FindFirstChild("UpperTorso") ~= nil
end

local function ParseColor(player, color, useTeamColor, isOutline)
    if color == "Team Color" or (useTeamColor and not isOutline) then
        return (player.Team and player.Team.TeamColor.Color) or Color3.new(1, 1, 1)
    end
    return color
end

-- ESP Object Class
local ESPObject = {}
ESPObject.__index = ESPObject

function ESPObject.new(player, interface)
    local self = setmetatable({}, ESPObject)
    self.player = player
    self.interface = interface
    self.drawings = {}
    self.cache = {}
    
    self:CreateDrawings()
    self:Connect()
    
    return self
end

function ESPObject:CreateDrawing(class, properties)
    local drawing = Drawing.new(class)
    for prop, value in pairs(properties) do
        pcall(function() drawing[prop] = value end)
    end
    insert(self.drawings, drawing)
    return drawing
end

function ESPObject:CreateDrawings()
    -- Box
    self.boxOutline = self:CreateDrawing("Square", {Thickness = 3, Filled = false, Visible = false})
    self.box = self:CreateDrawing("Square", {Thickness = 1, Filled = false, Visible = false})
    self.boxFill = self:CreateDrawing("Square", {Filled = true, Visible = false})
    
    -- Health bar
    self.healthBarOutline = self:CreateDrawing("Line", {Thickness = 3, Visible = false})
    self.healthBar = self:CreateDrawing("Line", {Thickness = 1, Visible = false})
    self.healthText = self:CreateDrawing("Text", {Center = true, Visible = false})
    
    -- Text
    self.nameText = self:CreateDrawing("Text", {Center = true, Visible = false, Text = self.player.DisplayName})
    self.distanceText = self:CreateDrawing("Text", {Center = true, Visible = false})
    self.weaponText = self:CreateDrawing("Text", {Center = true, Visible = false})
    
    -- Tracer
    self.tracerOutline = self:CreateDrawing("Line", {Thickness = 3, Visible = false})
    self.tracer = self:CreateDrawing("Line", {Thickness = 1, Visible = false})
    
    -- Off-screen arrow
    self.arrowOutline = self:CreateDrawing("Triangle", {Thickness = 3, Visible = false})
    self.arrow = self:CreateDrawing("Triangle", {Filled = true, Visible = false})
    
    -- Skeleton (14 bones for R15, 5 for R6)
    self.skeletonLines = {}
    for i = 1, 14 do
        local outline = self:CreateDrawing("Line", {Thickness = 3, Visible = false})
        local line = self:CreateDrawing("Line", {Thickness = 1, Visible = false})
        insert(self.skeletonLines, {outline = outline, line = line})
    end
    
    -- Look direction indicator
    self.lookLineOutline = self:CreateDrawing("Line", {Thickness = 3, Visible = false})
    self.lookLine = self:CreateDrawing("Line", {Thickness = 1, Visible = false})
    
    -- Highlight (Chams)
    self.highlight = Instance.new("Highlight", Container)
    self.highlight.Enabled = false
end

function ESPObject:Connect()
    self.connection = RunService.Heartbeat:Connect(function(dt)
        self:Update(dt)
    end)
end

function ESPObject:Update(deltaTime)
    local interface = self.interface
    local character = interface.getCharacter(self.player)
    local isFriendly = interface.isFriendly(self.player)
    local settings = interface.teamSettings[isFriendly and "friendly" or "enemy"]
    
    -- Check if enabled
    local enabled = settings.enabled and character and character.Parent
    if not enabled or (interface.whitelist and #interface.whitelist > 0 and not table.find(interface.whitelist, self.player.UserId)) then
        self:Hide()
        return
    end
    
    -- Get head position for distance check
    local head = character:FindFirstChild("Head")
    if not head then
        self:Hide()
        return
    end
    
    local headPos, onScreen, depth = WorldToScreen(head.Position)
    
    -- Distance check
    if interface.sharedSettings.limitDistance and depth > interface.sharedSettings.maxDistance then
        self:Hide()
        return
    end
    
    self.cache.onScreen = onScreen
    self.cache.depth = depth
    self.cache.settings = settings
    self.cache.character = character
    self.cache.headPos = headPos
    
    -- Get health
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if humanoid then
        self.cache.health = humanoid.Health
        self.cache.maxHealth = humanoid.MaxHealth
    else
        self.cache.health = 100
        self.cache.maxHealth = 100
    end
    
    -- Get weapon
    self.cache.weapon = interface.getWeapon(self.player)
    
    if onScreen then
        self:RenderOnScreen()
    else
        self:RenderOffScreen()
    end
    
    self:UpdateChams()
end

function ESPObject:RenderOnScreen()
    local cache = self.cache
    local settings = cache.settings
    local character = cache.character
    local interface = self.interface
    local sharedSettings = interface.sharedSettings
    
    -- Calculate bounding box
    local cframe, size = GetCharacterBounds(character)
    if not cframe then
        self:Hide()
        return
    end
    
    local corners = CalculateBoxCorners(cframe, size)
    
    -- Box
    if settings.box then
        self.box.Visible = true
        self.box.Position = corners.topLeft
        self.box.Size = corners.bottomRight - corners.topLeft
        self.box.Color = ParseColor(self.player, settings.boxColor[1], sharedSettings.useTeamColor)
        self.box.Transparency = settings.boxColor[2]
        
        if settings.boxOutline then
            self.boxOutline.Visible = true
            self.boxOutline.Position = self.box.Position
            self.boxOutline.Size = self.box.Size
            self.boxOutline.Color = ParseColor(self.player, settings.boxOutlineColor[1], false, true)
            self.boxOutline.Transparency = settings.boxOutlineColor[2]
        else
            self.boxOutline.Visible = false
        end
    else
        self.box.Visible = false
        self.boxOutline.Visible = false
    end
    
    -- Box fill
    if settings.boxFill then
        self.boxFill.Visible = true
        self.boxFill.Position = corners.topLeft
        self.boxFill.Size = corners.bottomRight - corners.topLeft
        self.boxFill.Color = ParseColor(self.player, settings.boxFillColor[1], sharedSettings.useTeamColor)
        self.boxFill.Transparency = settings.boxFillColor[2]
    else
        self.boxFill.Visible = false
    end
    
    -- Health bar
    if settings.healthBar then
        local healthPercent = cache.health / cache.maxHealth
        local barStart = corners.topLeft - Vector2.new(6, 0)
        local barEnd = corners.bottomLeft - Vector2.new(6, 0)
        
        self.healthBar.Visible = true
        self.healthBar.From = barEnd
        self.healthBar.To = barEnd:Lerp(barStart, healthPercent)
        self.healthBar.Color = settings.healthyColor:Lerp(settings.dyingColor, 1 - healthPercent)
        
        if settings.healthBarOutline then
            self.healthBarOutline.Visible = true
            self.healthBarOutline.From = barEnd + Vector2.new(0, 1)
            self.healthBarOutline.To = barStart - Vector2.new(0, 1)
            self.healthBarOutline.Color = ParseColor(self.player, settings.healthBarOutlineColor[1], false, true)
            self.healthBarOutline.Transparency = settings.healthBarOutlineColor[2]
        else
            self.healthBarOutline.Visible = false
        end
        
        if settings.healthText then
            self.healthText.Visible = true
            self.healthText.Text = round(cache.health) .. " HP"
            self.healthText.Size = sharedSettings.textSize
            self.healthText.Font = sharedSettings.textFont
            self.healthText.Color = ParseColor(self.player, settings.healthTextColor[1], sharedSettings.useTeamColor)
            self.healthText.Transparency = settings.healthTextColor[2]
            self.healthText.Outline = settings.healthTextOutline
            self.healthText.OutlineColor = settings.healthTextOutlineColor
            self.healthText.Position = barEnd:Lerp(barStart, healthPercent) - Vector2.new(12 + self.healthText.TextBounds.X / 2, 0)
        else
            self.healthText.Visible = false
        end
    else
        self.healthBar.Visible = false
        self.healthBarOutline.Visible = false
        self.healthText.Visible = false
    end
    
    -- Name
    if settings.name then
        self.nameText.Visible = true
        self.nameText.Size = sharedSettings.textSize
        self.nameText.Font = sharedSettings.textFont
        self.nameText.Color = ParseColor(self.player, settings.nameColor[1], sharedSettings.useTeamColor)
        self.nameText.Transparency = settings.nameColor[2]
        self.nameText.Outline = settings.nameOutline
        self.nameText.OutlineColor = settings.nameOutlineColor
        self.nameText.Position = (corners.topLeft + corners.topRight) * 0.5 - Vector2.new(0, self.nameText.TextBounds.Y + 2)
    else
        self.nameText.Visible = false
    end
    
    -- Distance
    local yOffset = 0
    if settings.distance then
        self.distanceText.Visible = true
        self.distanceText.Text = round(cache.depth) .. " studs"
        self.distanceText.Size = sharedSettings.textSize
        self.distanceText.Font = sharedSettings.textFont
        self.distanceText.Color = ParseColor(self.player, settings.distanceColor[1], sharedSettings.useTeamColor)
        self.distanceText.Transparency = settings.distanceColor[2]
        self.distanceText.Outline = settings.distanceOutline
        self.distanceText.OutlineColor = settings.distanceOutlineColor
        self.distanceText.Position = (corners.bottomLeft + corners.bottomRight) * 0.5 + Vector2.new(0, 2)
        yOffset = self.distanceText.TextBounds.Y + 2
    else
        self.distanceText.Visible = false
    end
    
    -- Weapon
    if settings.weapon and cache.weapon then
        self.weaponText.Visible = true
        self.weaponText.Text = cache.weapon
        self.weaponText.Size = sharedSettings.textSize
        self.weaponText.Font = sharedSettings.textFont
        self.weaponText.Color = ParseColor(self.player, settings.weaponColor[1], sharedSettings.useTeamColor)
        self.weaponText.Transparency = settings.weaponColor[2]
        self.weaponText.Outline = settings.weaponOutline
        self.weaponText.OutlineColor = settings.weaponOutlineColor
        self.weaponText.Position = (corners.bottomLeft + corners.bottomRight) * 0.5 + Vector2.new(0, 2 + yOffset)
    else
        self.weaponText.Visible = false
    end
    
    -- Tracer
    if settings.tracer then
        local tracerOrigin = 
            settings.tracerOrigin == "Top" and Vector2.new(Camera.ViewportSize.X / 2, 0) or
            settings.tracerOrigin == "Middle" and Camera.ViewportSize / 2 or
            Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y)
        
        self.tracer.Visible = true
        self.tracer.From = tracerOrigin
        self.tracer.To = (corners.bottomLeft + corners.bottomRight) * 0.5
        self.tracer.Color = ParseColor(self.player, settings.tracerColor[1], sharedSettings.useTeamColor)
        self.tracer.Transparency = settings.tracerColor[2]
        
        if settings.tracerOutline then
            self.tracerOutline.Visible = true
            self.tracerOutline.From = self.tracer.From
            self.tracerOutline.To = self.tracer.To
            self.tracerOutline.Color = ParseColor(self.player, settings.tracerOutlineColor[1], false, true)
            self.tracerOutline.Transparency = settings.tracerOutlineColor[2]
        else
            self.tracerOutline.Visible = false
        end
    else
        self.tracer.Visible = false
        self.tracerOutline.Visible = false
    end
    
    -- Skeleton
    self:RenderSkeleton()
    
    -- Look direction
    self:RenderLookDirection()
    
    -- Hide off-screen elements
    self.arrow.Visible = false
    self.arrowOutline.Visible = false
end

function ESPObject:RenderSkeleton()
    local cache = self.cache
    local settings = cache.settings
    local character = cache.character
    
    if not settings.skeleton then
        for _, line in ipairs(self.skeletonLines) do
            line.line.Visible = false
            line.outline.Visible = false
        end
        return
    end
    
    local isR15 = IsR15(character)
    local connections = isR15 and BONE_CONNECTIONS or BONE_CONNECTIONS_R6
    
    for i, connection in ipairs(connections) do
        local part1 = character:FindFirstChild(connection[1])
        local part2 = character:FindFirstChild(connection[2])
        
        if part1 and part2 and self.skeletonLines[i] then
            local pos1, onScreen1 = WorldToScreen(part1.Position)
            local pos2, onScreen2 = WorldToScreen(part2.Position)
            
            if onScreen1 and onScreen2 then
                local line = self.skeletonLines[i].line
                local outline = self.skeletonLines[i].outline
                
                line.Visible = true
                line.From = pos1
                line.To = pos2
                line.Color = ParseColor(self.player, settings.skeletonColor[1], self.interface.sharedSettings.useTeamColor)
                line.Transparency = settings.skeletonColor[2]
                
                if settings.skeletonOutline then
                    outline.Visible = true
                    outline.From = pos1
                    outline.To = pos2
                    outline.Color = ParseColor(self.player, settings.skeletonOutlineColor[1], false, true)
                    outline.Transparency = settings.skeletonOutlineColor[2]
                else
                    outline.Visible = false
                end
            else
                self.skeletonLines[i].line.Visible = false
                self.skeletonLines[i].outline.Visible = false
            end
        elseif self.skeletonLines[i] then
            self.skeletonLines[i].line.Visible = false
            self.skeletonLines[i].outline.Visible = false
        end
    end
    
    -- Hide unused lines
    for i = #connections + 1, #self.skeletonLines do
        self.skeletonLines[i].line.Visible = false
        self.skeletonLines[i].outline.Visible = false
    end
end

function ESPObject:RenderLookDirection()
    local cache = self.cache
    local settings = cache.settings
    local character = cache.character
    
    if not settings.lookDirection then
        self.lookLine.Visible = false
        self.lookLineOutline.Visible = false
        return
    end
    
    local head = character:FindFirstChild("Head")
    if not head then
        self.lookLine.Visible = false
        self.lookLineOutline.Visible = false
        return
    end
    
    local lookVector = head.CFrame.LookVector
    local endPos = head.Position + lookVector * settings.lookDirectionLength
    
    local startScreen, onScreen1 = WorldToScreen(head.Position)
    local endScreen, onScreen2 = WorldToScreen(endPos)
    
    if onScreen1 and onScreen2 then
        self.lookLine.Visible = true
        self.lookLine.From = startScreen
        self.lookLine.To = endScreen
        self.lookLine.Color = ParseColor(self.player, settings.lookDirectionColor[1], self.interface.sharedSettings.useTeamColor)
        self.lookLine.Transparency = settings.lookDirectionColor[2]
        
        if settings.lookDirectionOutline then
            self.lookLineOutline.Visible = true
            self.lookLineOutline.From = startScreen
            self.lookLineOutline.To = endScreen
            self.lookLineOutline.Color = ParseColor(self.player, settings.lookDirectionOutlineColor[1], false, true)
            self.lookLineOutline.Transparency = settings.lookDirectionOutlineColor[2]
        else
            self.lookLineOutline.Visible = false
        end
    else
        self.lookLine.Visible = false
        self.lookLineOutline.Visible = false
    end
end

function ESPObject:RenderOffScreen()
    local cache = self.cache
    local settings = cache.settings
    
    if not settings.offScreenArrow then
        self.arrow.Visible = false
        self.arrowOutline.Visible = false
        return
    end
    
    local character = cache.character
    local head = character:FindFirstChild("Head")
    if not head then return end
    
    -- Calculate direction
    local camCFrame = Camera.CFrame
    local flatCFrame = CFrame.fromMatrix(camCFrame.Position, camCFrame.RightVector, Vector3.new(0, 1, 0))
    local objectSpace = flatCFrame:PointToObjectSpace(head.Position)
    local direction = Vector2.new(objectSpace.X, objectSpace.Z).Unit
    
    -- Calculate arrow position
    local center = Camera.ViewportSize * 0.5
    local arrowPos = center + direction * settings.offScreenArrowRadius
    arrowPos = Vector2.new(
        math.clamp(arrowPos.X, 25, Camera.ViewportSize.X - 25),
        math.clamp(arrowPos.Y, 25, Camera.ViewportSize.Y - 25)
    )
    
    -- Rotate arrow
    local angle = atan2(direction.Y, direction.X)
    local size = settings.offScreenArrowSize
    
    local function rotatePoint(point, pivot, angle)
        local s, c = sin(angle), cos(angle)
        local translated = point - pivot
        return Vector2.new(
            translated.X * c - translated.Y * s,
            translated.X * s + translated.Y * c
        ) + pivot
    end
    
    local pointA = arrowPos
    local pointB = arrowPos - Vector2.new(size, size * 0.5)
    local pointC = arrowPos - Vector2.new(size, -size * 0.5)
    
    pointB = rotatePoint(pointB, arrowPos, angle)
    pointC = rotatePoint(pointC, arrowPos, angle)
    
    self.arrow.Visible = true
    self.arrow.PointA = pointA
    self.arrow.PointB = pointB
    self.arrow.PointC = pointC
    self.arrow.Color = ParseColor(self.player, settings.offScreenArrowColor[1], self.interface.sharedSettings.useTeamColor)
    self.arrow.Transparency = settings.offScreenArrowColor[2]
    
    if settings.offScreenArrowOutline then
        self.arrowOutline.Visible = true
        self.arrowOutline.PointA = pointA
        self.arrowOutline.PointB = pointB
        self.arrowOutline.PointC = pointC
        self.arrowOutline.Color = ParseColor(self.player, settings.offScreenArrowOutlineColor[1], false, true)
        self.arrowOutline.Transparency = settings.offScreenArrowOutlineColor[2]
    else
        self.arrowOutline.Visible = false
    end
    
    -- Hide on-screen elements
    self.box.Visible = false
    self.boxOutline.Visible = false
    self.boxFill.Visible = false
    self.healthBar.Visible = false
    self.healthBarOutline.Visible = false
    self.healthText.Visible = false
    self.nameText.Visible = false
    self.distanceText.Visible = false
    self.weaponText.Visible = false
    self.tracer.Visible = false
    self.tracerOutline.Visible = false
    self.lookLine.Visible = false
    self.lookLineOutline.Visible = false
    
    for _, line in ipairs(self.skeletonLines) do
        line.line.Visible = false
        line.outline.Visible = false
    end
end

function ESPObject:UpdateChams()
    local cache = self.cache
    local settings = cache.settings
    local character = cache.character
    
    if settings.chams and character then
        self.highlight.Enabled = true
        self.highlight.Adornee = character
        self.highlight.FillColor = ParseColor(self.player, settings.chamsFillColor[1], self.interface.sharedSettings.useTeamColor)
        self.highlight.FillTransparency = settings.chamsFillColor[2]
        self.highlight.OutlineColor = ParseColor(self.player, settings.chamsOutlineColor[1], false, true)
        self.highlight.OutlineTransparency = settings.chamsOutlineColor[2]
        self.highlight.DepthMode = settings.chamsVisibleOnly and "Occluded" or "AlwaysOnTop"
    else
        self.highlight.Enabled = false
    end
end

function ESPObject:Hide()
    for _, drawing in ipairs(self.drawings) do
        drawing.Visible = false
    end
    self.highlight.Enabled = false
end

function ESPObject:Destroy()
    if self.connection then
        self.connection:Disconnect()
    end
    
    for _, drawing in ipairs(self.drawings) do
        drawing:Remove()
    end
    
    if self.highlight then
        self.highlight:Destroy()
    end
    
    clear(self)
end

-- Interface
local ESPInterface = {
    _loaded = false,
    _objects = {},
    whitelist = {},
    
    sharedSettings = {
        textSize = 13,
        textFont = 2,
        limitDistance = false,
        maxDistance = 500,
        useTeamColor = false
    },
    
    teamSettings = {
        enemy = {
            enabled = true,
            
            -- Box
            box = true,
            boxColor = {Color3.new(1, 0, 0), 1},
            boxOutline = true,
            boxOutlineColor = {Color3.new(), 1},
            boxFill = false,
            boxFillColor = {Color3.new(1, 0, 0), 0.5},
            
            -- Health
            healthBar = true,
            healthyColor = Color3.new(0, 1, 0),
            dyingColor = Color3.new(1, 0, 0),
            healthBarOutline = true,
            healthBarOutlineColor = {Color3.new(), 0.5},
            healthText = true,
            healthTextColor = {Color3.new(1, 1, 1), 1},
            healthTextOutline = true,
            healthTextOutlineColor = Color3.new(),
            
            -- Text
            name = true,
            nameColor = {Color3.new(1, 1, 1), 1},
            nameOutline = true,
            nameOutlineColor = Color3.new(),
            
            distance = true,
            distanceColor = {Color3.new(1, 1, 1), 1},
            distanceOutline = true,
            distanceOutlineColor = Color3.new(),
            
            weapon = false,
            weaponColor = {Color3.new(1, 1, 1), 1},
            weaponOutline = true,
            weaponOutlineColor = Color3.new(),
            
            -- Tracer
            tracer = false,
            tracerOrigin = "Bottom",
            tracerColor = {Color3.new(1, 0, 0), 1},
            tracerOutline = true,
            tracerOutlineColor = {Color3.new(), 1},
            
            -- Skeleton
            skeleton = true,
            skeletonColor = {Color3.new(1, 1, 1), 1},
            skeletonOutline = true,
            skeletonOutlineColor = {Color3.new(), 1},
            
            -- Look direction
            lookDirection = false,
            lookDirectionLength = 5,
            lookDirectionColor = {Color3.new(1, 0, 0), 1},
            lookDirectionOutline = true,
            lookDirectionOutlineColor = {Color3.new(), 1},
            
            -- Off-screen arrow
            offScreenArrow = true,
            offScreenArrowColor = {Color3.new(1, 0, 0), 1},
            offScreenArrowSize = 15,
            offScreenArrowRadius = 150,
            offScreenArrowOutline = true,
            offScreenArrowOutlineColor = {Color3.new(), 1},
            
            -- Chams
            chams = false,
            chamsVisibleOnly = false,
            chamsFillColor = {Color3.new(1, 0, 0), 0.5},
            chamsOutlineColor = {Color3.new(1, 0, 0), 0}
        },
        
        friendly = {
            enabled = false,
            
            -- Box
            box = true,
            boxColor = {Color3.new(0, 1, 0), 1},
            boxOutline = true,
            boxOutlineColor = {Color3.new(), 1},
            boxFill = false,
            boxFillColor = {Color3.new(0, 1, 0), 0.5},
            
            -- Health
            healthBar = true,
            healthyColor = Color3.new(0, 1, 0),
            dyingColor = Color3.new(1, 0, 0),
            healthBarOutline = true,
            healthBarOutlineColor = {Color3.new(), 0.5},
            healthText = true,
            healthTextColor = {Color3.new(1, 1, 1), 1},
            healthTextOutline = true,
            healthTextOutlineColor = Color3.new(),
            
            -- Text
            name = true,
            nameColor = {Color3.new(1, 1, 1), 1},
            nameOutline = true,
            nameOutlineColor = Color3.new(),
            
            distance = true,
            distanceColor = {Color3.new(1, 1, 1), 1},
            distanceOutline = true,
            distanceOutlineColor = Color3.new(),
            
            weapon = false,
            weaponColor = {Color3.new(1, 1, 1), 1},
            weaponOutline = true,
            weaponOutlineColor = Color3.new(),
            
            -- Tracer
            tracer = false,
            tracerOrigin = "Bottom",
            tracerColor = {Color3.new(0, 1, 0), 1},
            tracerOutline = true,
            tracerOutlineColor = {Color3.new(), 1},
            
            -- Skeleton
            skeleton = true,
            skeletonColor = {Color3.new(1, 1, 1), 1},
            skeletonOutline = true,
            skeletonOutlineColor = {Color3.new(), 1},
            
            -- Look direction
            lookDirection = false,
            lookDirectionLength = 5,
            lookDirectionColor = {Color3.new(0, 1, 0), 1},
            lookDirectionOutline = true,
            lookDirectionOutlineColor = {Color3.new(), 1},
            
            -- Off-screen arrow
            offScreenArrow = true,
            offScreenArrowColor = {Color3.new(0, 1, 0), 1},
            offScreenArrowSize = 15,
            offScreenArrowRadius = 150,
            offScreenArrowOutline = true,
            offScreenArrowOutlineColor = {Color3.new(), 1},
            
            -- Chams
            chams = false,
            chamsVisibleOnly = false,
            chamsFillColor = {Color3.new(0, 1, 0), 0.5},
            chamsOutlineColor = {Color3.new(0, 1, 0), 0}
        }
    }
}

-- Game-specific functions (override these for your game)
function ESPInterface.getCharacter(player)
    return player.Character
end

function ESPInterface.getHealth(player)
    local character = ESPInterface.getCharacter(player)
    if character then
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            return humanoid.Health, humanoid.MaxHealth
        end
    end
    return 100, 100
end

function ESPInterface.getWeapon(player)
    local character = ESPInterface.getCharacter(player)
    if character then
        local tool = character:FindFirstChildOfClass("Tool")
        if tool then
            return tool.Name
        end
    end
    return nil
end

function ESPInterface.isFriendly(player)
    return player.Team and player.Team == LocalPlayer.Team
end

function ESPInterface.getTeamColor(player)
    return player.Team and player.Team.TeamColor.Color
end

-- Core functions
function ESPInterface.Load()
    assert(not ESPInterface._loaded, "ESP is already loaded")
    
    local function addPlayer(player)
        if player == LocalPlayer then return end
        if ESPInterface._objects[player] then return end
        
        ESPInterface._objects[player] = ESPObject.new(player, ESPInterface)
    end
    
    local function removePlayer(player)
        local object = ESPInterface._objects[player]
        if object then
            object:Destroy()
            ESPInterface._objects[player] = nil
        end
    end
    
    -- Add existing players
    for _, player in ipairs(Players:GetPlayers()) do
        addPlayer(player)
    end
    
    -- Connect events
    ESPInterface._playerAdded = Players.PlayerAdded:Connect(addPlayer)
    ESPInterface._playerRemoving = Players.PlayerRemoving:Connect(removePlayer)
    
    ESPInterface._loaded = true
    print("[ESP] Loaded successfully")
end

function ESPInterface.Unload()
    assert(ESPInterface._loaded, "ESP is not loaded")
    
    -- Destroy all objects
    for player, object in pairs(ESPInterface._objects) do
        object:Destroy()
    end
    
    clear(ESPInterface._objects)
    
    -- Disconnect events
    if ESPInterface._playerAdded then
        ESPInterface._playerAdded:Disconnect()
    end
    
    if ESPInterface._playerRemoving then
        ESPInterface._playerRemoving:Disconnect()
    end
    
    ESPInterface._loaded = false
    print("[ESP] Unloaded successfully")
end

function ESPInterface.Toggle()
    if ESPInterface._loaded then
        ESPInterface.Unload()
    else
        ESPInterface.Load()
    end
end

function ESPInterface.SetTeamCheck(enabled)
    ESPInterface.sharedSettings.useTeamColor = enabled
end

function ESPInterface.SetMaxDistance(distance)
    ESPInterface.sharedSettings.maxDistance = distance
end

function ESPInterface.SetLimitDistance(enabled)
    ESPInterface.sharedSettings.limitDistance = enabled
end

function ESPInterface.AddToWhitelist(userId)
    if not table.find(ESPInterface.whitelist, userId) then
        insert(ESPInterface.whitelist, userId)
    end
end

function ESPInterface.RemoveFromWhitelist(userId)
    local index = table.find(ESPInterface.whitelist, userId)
    if index then
        table.remove(ESPInterface.whitelist, index)
    end
end

function ESPInterface.ClearWhitelist()
    clear(ESPInterface.whitelist)
end

-- Preset configurations
function ESPInterface.ApplyPreset(preset)
    if preset == "Minimal" then
        ESPInterface.teamSettings.enemy.box = true
        ESPInterface.teamSettings.enemy.name = true
        ESPInterface.teamSettings.enemy.healthBar = false
        ESPInterface.teamSettings.enemy.skeleton = false
        ESPInterface.teamSettings.enemy.tracer = false
        ESPInterface.teamSettings.enemy.chams = false
        
    elseif preset == "Full" then
        ESPInterface.teamSettings.enemy.box = true
        ESPInterface.teamSettings.enemy.name = true
        ESPInterface.teamSettings.enemy.healthBar = true
        ESPInterface.teamSettings.enemy.skeleton = true
        ESPInterface.teamSettings.enemy.tracer = true
        ESPInterface.teamSettings.enemy.distance = true
        ESPInterface.teamSettings.enemy.chams = true
        
    elseif preset == "Performance" then
        ESPInterface.teamSettings.enemy.box = true
        ESPInterface.teamSettings.enemy.name = true
        ESPInterface.teamSettings.enemy.healthBar = true
        ESPInterface.teamSettings.enemy.skeleton = false
        ESPInterface.teamSettings.enemy.tracer = false
        ESPInterface.teamSettings.enemy.chams = false
        ESPInterface.sharedSettings.limitDistance = true
        ESPInterface.sharedSettings.maxDistance = 300
        
    elseif preset == "Skeleton" then
        ESPInterface.teamSettings.enemy.box = false
        ESPInterface.teamSettings.enemy.skeleton = true
        ESPInterface.teamSettings.enemy.name = true
        ESPInterface.teamSettings.enemy.healthBar = true
        ESPInterface.teamSettings.enemy.tracer = false
        ESPInterface.teamSettings.enemy.chams = false
    end
    
    print("[ESP] Applied preset: " .. preset)
end

return ESPInterface
